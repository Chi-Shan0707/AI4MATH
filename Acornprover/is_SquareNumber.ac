from nat import Nat
numerals Nat
define is_SquareNumber(n:Nat) -> Bool
{
    exists(m: Nat){
        m*m=n
    }
}
theorem n_plus_one(n: Nat){
    is_SquareNumber(n) implies if n=0{
        is_SquareNumber(n+1)
    }else{
        not is_SquareNumber(n+1)
    }
}
by{
    let m: Nat satisfy{
            m*m=n
    }
    if n=0{
        n+1=1
        1*1=1
        is_SquareNumber(1)
    }
    else{
        n>0
        n>=1
        m>=0
        m*m=n
        m>=1
        2*m>=2
        2*m>0
        (m*m+2*m+1)-(n+1)=2*m
        (m*m+2*m+1)-(n+1)>0
        // 重新组织推导过程
        (m*m+2*m+1) = (n+1) + 2*m
        2*m>0
        (m*m+2*m+1) > (n+1)
        (m+1)*(m+1)=(m+1)*m+m+1
        (m+1)*m+m+1=m*m+m+m+1
        (m+1)*(m+1)=m*m+2*m+1
        (m+1)*(m+1)>(n+1)
        forall (k:Nat){
            
            if k<=m{
                0<=k
                0<m
                k*k<=m*k
                m*k<=m*m
                k*k<=m*m
                m*m=n
                m*m<n+1
                k*k<n+1
                k*k!=n+1
            }
            else{
                m>0
                k>=m+1
                // 添加详细的推导步骤来证明 k*k>=(m+1)*(m+1)
                k>=m+1 and m+1>=1
                k*k>=k*(m+1) and k*(m+1)>= (m+1)*(m+1)
                k*k>=(m+1)*(m+1)
                (m+1)*(m+1)=m*m+2*m+1
                k*k>=m*m+2*m+1
                m*m+2*m+1>n+1
                k*k>n+1
                k*k!=n+1
            }
            k*k!=n+1
        }
        not is_SquareNumber(n+1)
    }
}